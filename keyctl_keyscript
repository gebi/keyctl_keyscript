#!/bin/bash
# keyctl_keyscript - to use in /etc/crypttab as keyscript
#  allows to cache passwords for cryptdevices for 60s
#  password is linked for cryptdevices with the same _FAKE_ keyfile
#  keyfile is the value of the 3. field from /etc/crypttab if keyscript is used
#
# sample crypttab entries:
# test1   /dev/loop1    /etc/inittab    luks,keyscript=/sbin/keyscript
# test2   /dev/loop2    /etc/inittab    luks,keyscript=/sbin/keyscript
# test3   /dev/loop3    /etc/passwd     luks,keyscript=/sbin/keyscript
#
#  test1 and test2 have the same identifier thus test2 does not need a password
#  typed in manually
#
#  hint: at first the identifier '/etc/inittab' seems strange, though it's
#        choosen that the crypttab script does not error out because of a
#        missing file.

die()
{
    echo -e "$@" >&2
    exit 1
}

# the keyfile given from crypttab is used as identifier in the keyring
# including the prefix "cryptkey-"
ID_="cryptkey-$1"
TIMEOUT_='60'
ASKPASS_='/lib/cryptsetup/askpass'
USE_ASKPASS_='false'
PROMPT_="Caching passphrase for ${CRYPTTAB_SOURCE}: "

test -x "$ASKPASS_" && USE_ASKPASS_='true'

KID_=$(keyctl search @u user "$ID_" 2>/dev/null)
if [[ $? != 0 || $KID_ == "" ]]; then
    # key not found, ask the user
    if [[ $USE_ASKPASS_ == 'true' ]]; then
        KEY_=$($ASKPASS_ "$PROMPT_") || die "Error executing $ASKPASS_"
    else
        echo -n "$PROMPT_" >&2
        if ! read -res KEY_; then
            die "Error reading key from /dev/stdin"
        else
            echo >&2
        fi
    fi
    KID_=$(echo -n "$KEY_" |keyctl padd user "$ID_" @u)
    [[ $KID_ == "" ]] && die "Error adding passphrase to kernel keyring"
    if ! keyctl timeout $KID_ $TIMEOUT_; then
        keyctl unlink $KID_ @u
        die "Error setting timeout on key ($KID_), removing"
    fi
else
    echo "Using cached passphrase for ${CRYPTTAB_SOURCE}." >&2
fi
keyctl pipe $KID_
